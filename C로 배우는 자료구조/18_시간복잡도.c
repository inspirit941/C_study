/*
자료구조와 알고리즘을 평가하는 방법. 둘 중 어떤 알고리즘이 더 나은지 평가하는 방법론

알고리즘의 분석
    - 알고리즘의 자원 사용량을 분석
    - 자원이란 실행 시간, 메모리, 저장장치, 통신 등
    - 여기서는 '실행시간의 분석'을 다룬다.
예전에는 메모리 용량도 상당히 중요했으나,
요즘은 기술발달로 메모리 값이 내려가면서 중요도가 하락하긴 함.
*/
/* 시간복잡도
 - 실행시간은 실행환경에 따라 달라진다. - 하드웨어, 운영체제, 언어, 컴파일러 등
 따라서 실행시간을 가지고 시간복잡도를 판단할 수 없음
 - 실행 시간을 측정하는 대신 "연산의 실행횟수"를 카운트한다.
 - 연산의 실행 횟수는 "입력 데이터의 크기에 관한 함수"로 표현된다.
 - 데이터의 크기가 같더라도 실제 데이터에 따라서도 달라진다.
 (최악의 경우 시간복잡도 - Worst case analysis)
 (평균 시간복잡도 - Average case analysis)

점근적 분석
    데이터의 개수 n이 무한대로 나아갈 때 수행시간이 증가하는 growth rate.
    시간복잡도를 표현하는 기법이다. O-표기, 세타-표기 등을 사용한다.

    유일한 분석법도 아니고 가장 좋은 분석법도 아니지만
    상대적으로 가장 간단한 분석법이며 알고리즘 실행환경에 비의존적이다.
    그래서 가장 광범위하게 쓰인다.
ㅏ
*/

// n개의 데이터
int sample(int data[],int n){
    int k = n/2;
    return data[k];
}
// n을 받고 n/2를 계산해 반환. 
// 이 경우 n에 관계없이 계산 한 번으로 소요된다. 다시 말해 n의 개수와 무관한 실행이다.
// 따라서 알고리즘의 시간복잡도는 O(1)이다.


// 선형 시간복잡도.

int sum(int data[],int n){
    int sum=0;
    for (int i=0;i<n;i++){
        sum=sum+data[i];
    }
    return sum;
}
// n개의 데이터를 받으면 n번 시행
// 가장 자주 실행되는 문장의 실행횟수가 n번이라면
// 모든 문장의 실행횟수의 합은 n에 선형적으로 비례하며
// 실행횟수의 합도 n에 비례한다. (k * n)같은 느낌

// 따라서 이 경우 선형 시간복잡도를 가지며 O(n)이다.
// 최악의 경우 / 평균 복잡도가 동일하다

//ex) 선형 시간복잡도 -> 순서 탐색
#include <stdbool.h>

int search(int n, int data[], int target){
    for (int i=0;i<n;i++){
        if (data[i]==target){
            return i;
        }
    }
    return -1;
}
// 최악의 경우, 시간복잡도는 O(n)이다. for문을 전부 돌아야 하기 때문
bool is_distinct(int n, int x[]){
    for (int i=0;i<n-1;i++){
        for (int j=i+1;j<n;j++){
            if (x[i]==x[j]){
                return false;
            }
        }
        return true;
    }
}
// 최악의 경우 저장된 모든 쌍을 비교하므로, 비교연산의 횟수는 n(n-1)/2이다.
// => O(n^2)가 최악의 경우 시간복잡도이다.


// 점근적 표기법 -> 알고리즘에 포함된 연산들의 실행횟수를 표기하는 기법.
// 최고차항의 차수만으로 표시
// 따라서 가장 자주 실행되는 연산 혹은 문장의 실행횟수를 고려하는 걸로도 충분하다.


// O(지수함수)나 O(팩토리얼)은 다항함수가 아님...


/*
이진검색과 정렬

1차원 배열이나 연결리스트와 같은 경우, 검색은 두 가지 방식이 있다.
 - 순차검색. Sequential search (배열에 target이 있는지 없는지 처음부터 끝까지)
 - 이진검색. Binary search
    배열에서만 일반적으로 적용할 수 있는 기법. (연결리스트에서는 사용 불가능)
    순차검색의 최악의 시간복잡도는 O(n)이지만, 이진검색은 좀 다름
*/

/* 이진검색의 특징
* 배열에 데이터들이 오름차순으로 정렬되어 있는 경우
즉, 배열에 저장되어 있어야 하고, 정렬되어 있어야 한다.
(정확히는, 배열에 저장되어있다는 의미는
데이터가 n개 저장되어 있다면, 예컨대 n/2번째의 데이터를 호출할 수 있어야 한다는 의미)

중간에서부터 시작해
찾고자 하는 데이터가 앞인지 뒤인지 찾는 것.


*/

int binarySearch(int n, char *data[], char *target){
    int begin =0, end = n-1;
    while (begin<=end){
        int middle = (begin+end)/2;
        int result = strcmp(data[middle],target);
        if(result ==0){
            return middle;
        }
        else if (result<0){ // 찾고자 하는 값이 중간보다 큰 경우
        // 간단히 말해, data[middle] - target < 0이다.
            begin = middle+1;
        }else{
            end = middle-1; //
        }
    }
    return -1;
}
// 한 번 비교할 때마다 남아 있는 데이터가 절반으로 줄어든다.
// 따라서 시간복잡도는 O(log2 N)이다. (로그 밑이 2)

// 데이터가 연결리스트에 오름차순으로 정렬되어 있다면??
// -> 연결리스트에서는 middle값을 O(1)시간에 읽을 수 없다.
// 따라서 이진검색이 불가능하다

// 순차검색의 시간복잡도는 O(n), 이진검색은 O(log2 N)이다. 이 차이는 크다.


// 버블 정렬
// 제일 큰 값을 찾아서 맨 뒤로 옮기고... 뭐 그런 방식
// 반대로 제일 작은 값을 위로 올리는 것이기도 함
void bubbleSort(int data[], int n){
    for (int i=n-1;i>0;i--){
        for (int j=0;j<i;j++){
            if (data[j]>data[j+1]){
                int tmp = data[j];
                data[j] = data[j+1];
                data[j+1] = tmp;
            } // data[j] 값이 j+1값보다 크면 한 칸 뒤로 옮겨라.
        }
    }
}
// 이 정렬의 시간복잡도는 O(n^2)

// 삽입정렬
// 삽입 연산을 반복 수행함으로써 데이터를 정렬하는 방식
void insertion_sort(int n, int data[]){
    for (int i=1;i<n;i++){
        int tmp = data[i];
        int j= i-1;
        while(j>=0 && data[j]>data[i]){
            data[j+1] = data[j];
            j--;
        }
        data[j+1] = tmp;
    }// 1번째 데이터를 받아서 정렬.
    // 두 번째 데이터를 받아서 첫 번째 데이터가 있는 배열에 넣고 정렬
    // 세 번째 데이터를 받아서 배열에 정렬......
}

// 최선의 경우: O(n) 번만으로 정렬 가능
// 최악의 경우: O(n^2)


/*
퀵소트 알고리즘
최악의 경우 O(n^2), 평균적인 시간복잡도는 O(n* log2 N)
최악의 경우 O(n*log 2 N)의 시간복잡도를 갖는 알고리즘
-> 합병정렬
-> 힙 정렬 등

보통 퀵소트 알고리즘을 라이브러리로 제공하는 프로그래밍 언어가 많다

만약 데이터가 배열이 아닌 연결리스트에 저장되어 있다면??
    -> O(n^2)의 시간복잡도를 벗어나기 어렵다.
    insertion sort와 비슷한 방향으로 ordered list에 넣는 게 보통의 최선
*/