메모리: 데이터 보관장소
byte(8bit)단위로 주소가 지정된다.
모든 변수는 주소를 갖는다.

메모리의 각 칸에 주소가 정해져 있다. 각 칸에는 한 바이트의 데이터가 저장된다.
모든 변수는 주소를 갖고 있다.
하나의 정수는 4바이트 공간 차지.
int sum;을 쓰면, 실제로는 4byte 공간에 해당 정수값이 쓰인다.

포인터: 메모리 주소를 값으로 갖는 변수.
int * prt와 같은 형태로 선언할 수 있다. 메모리 주소도 그냥 정수.

연산자 &는 특정 변수의 주소를 추출하는 연산자이다.
int sum = 10;
여기서 &sum은 10이 저장된 특정 메모리 주소를 불러온다.

포인터 주소값에 *를 입력할 경우, 해당 포인터 주소에 적힌 값으로 접근할 수 있다.

int x=1;
int * ip;
ip = &x; // 이렇게 하면 주소값을 넣는 변수 ip에 x=1이 기록된 메모리주소를 입력한다
*ip = 0 // 이 경우는 ip주소값의 변수(=x)를 바꾼다. x=0과 같은 의미.


배열의 이름은, 배열의 시작주소를 저장하는 포인터 변수임.
int a[10];
-> 10개의 정수를 수용할 수 있는 메모리(40바이트)가 할당됨.
&a[0] (a 배열의 첫 번째 값의 주소) = &a
+ &a는 그 값을 변경할 수 없다. (배열일 경우, 포인터 변수의 값을 보통의 포인터변수처럼 수정할 수 없다.)



함수를 정의할 때 배열을 매개변수로 받을 경우
int cal_sum(int array[]){
 //여기서 int array[] 대신 *array 로 변수명을 넣어도 동일하게 작동한다.
}

포인터 arithmatic

*a와 a[0]은 동일한 의미다.
a[1]은 *(a+1)과 동일하며, a[i]는 *(a+i)와 동일하다.
(a+i에서 i는 단순히 메모리 주소값+i를 의미하는 건 아니다.
메모리주소 한 칸을 의미함. 이를테면 숫자 하나에 4bit을 쓴다고 하면 a+i는 a번째 주소값 + i*4가 될 것)

cf. 16진수 변환해 쓸 때 : %x를 활용한다.
printf(%d %x, p, p)
하나의 정수는 4바이트를 쓰기 때문에
printf(%d %x, p+1, p+1)하면 p의 메모리주소값 + 4 가 출력된다.

char의 경우 1byte 사용. -> 메모리주소값이 1씩 증가
long long 타입: 8바이트 사용함. -> 메모리주소값이 8씩 증가한다.


