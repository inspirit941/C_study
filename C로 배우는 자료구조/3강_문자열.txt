문자열은 char타입의 배열 각 칸마다 문자 하나씩 저장된다.

C에서 문자열을 저장하는 방식
-> 문자열을 넣는 배열을 설정하고 각 메모리 주소마다 한 글자씩 할당

첫번째 방식 
char str[6];
str[0]='h';
str[1]='e';
...
str[5]='\0';
처럼 한 글자 한 글자 메모리에 할당하는 경우

c언어가 문자열을 다룰 경우
끝에 null 캐릭터가 있다는 걸 전제로 동작한다(printf같은 기본 내장함수조차도)
따라서 문자열 끝에 null 캐릭터('\0')를 넣어야 한다. 그래야 정상작동함.

두번째 방식

char str[] = "hello";
로 쉽게 만들 수 있다. 이 경우 str의 크기를 6으로 자동설정, null 캐릭터까지 자동으로 할당한다.

세번째 방식

char *str = "hello";로 만들어도 바로 위 명령어와 동일하다.
하지만 이 경우 정의된 문자열의 수정이 불가능하다는 점에서 위의 두 방법과 다르다.
이걸 string literal이라 부른다.


// 즉 위의 두 명령어는 '배열'을 정의한 것이기 때문에, 배열 안에 있는 문자를 변경할 수 있다.
// 하지만 마지막 방식으로 만든 건 문자 배열이 아니라 string literal로, 수정이 불가능하다.
// c언어 문법이 깔끔하지 못한 것이라고 볼 수 있을 듯하다. 둘 다 string literal이 된다거나 하는 식으로 통일성이 있어야 하는데, 그렇지 못하기 때문.


// 즉, *str로 정의한 경우 포인터변수이기에 전혀 다른, 새로운 문자열을 가리킬 수 있도록 변경이 가능하다.
// 다만 *str은 정의된 문자열을 수정하는 건 불가능하다. hello의 h를 바꾸는 건 안되지만, 생판 다른 문자열을 지정하는 건 가능
// 하지만 str[]의 경우 hello의 문자 하나하나를 변경하는 건 가능하지만, str[]가 단순히 배열의 이름을 의미하게 되므로
// str[]에 할당된 메모리주소가 전혀 다른 배열을 가리키도록 할 수는 없다고 함.

<string.h 라이브러리 함수>
strcpy 문자열 복사
strlen 문자열 길이
strcat 문자열 합치기
strcmp 문자열 비교
... 등등 많지만, 자주 쓰는 라이브러리는 이 정도.


-  여러 개의 단어를 포인터를 이용해 아래 그림과 같이 저장해보자 (동영상 15분경)

단어를 저장하는 배열을 만들어, 각 칸에 배열을 저장한다.

단어를 배열에 저장, 그리고 단어는 배열로 이루어져 있기 마련..

? words[100]; //전체 배열의 크기. 단어가 얼마나 들어올지에 달려 있음.
이 배열의 타입이 뭘까? -> 그 배열 각 칸에 저장되는 데이터의 타입을 의미함.
word 배열 안에 들어갈 값은 어떤 단어가 저장된 배열의 주소값. -> word는 포인터여야 한다.

포인터 변수를 선언할 때, 포인터를 통해 특정 주소로 이동했을 때
그 주소에 저장되는 데이터의 타입이 바로 포인터의 타입이다.

포인터 변수에 저장된 값으로 이동할 경우 단어가 저장된 배열을 만나게 될 거고,
그 배열의 주소는 배열 첫 번째 값의 메모리주소와 동일하며
문자니까 배열 첫 번째 값은 char일 것이다.

따라서 
#define BUFFER_SIZE 100

int main(){
    char * words[100];
    int n = 0; //number of strings
    char buffer[BUFFER_SIZE]; //단어의 크기는 100을 넘지 않는다.
    // input으로 단어를 받을 변수가 buffer임.
    while (n<4 && scanf("%s", buffer)!=EOF){ 
    // 숫자나 다른 값을 사용자에게서 받기 위해 scanf를 쓸 경우
    // 받게 될 변수의 주소값을 넣어야 한다. 즉 '&변수' 형태여야 함.
    // 그래야 그 변수의 주소값에 데이터가 정확히 저장된다.
    // 하지만 문자열을 넣을 경우 변수 앞에 굳이 주소값을 의미하는 &를 붙이지 않는다.
    // 왜냐하면, 배열의 이름 그 자체가 그 배열을 저장하고 있는 포인터 변수이기 때문.
        words[n]= buffer;
        n++;

    }
    for (int i=0; i<4; i++){
        printf("%s\n",words[i]);
    }
    // 만약 이렇게만 코드를 돌리면, 마지막에 입력한 변수만 네 번 printf로 표시된다.
    // buffer도 하나의 배열이다. 그 배열과 words라는 배열과의 관계를 설정하는데
    // buffer의 '주소'가 words에 기록되기 때문. 
    // words[n]=buffer의 의미는 buffer의 주소를 words[n]값에 넣으라는 의미다.
    // 따라서 words[n]은 전부 buffer라는 주소에 담긴 값을 불러오는 것이다. 값을 불러오는 게 아니라.
    
    // 해결법 1. words[n] = strcpy(words[n],buffer)
    // strcpy (str2, str1) -> str1의 문자열을 str2로 복사하라는 함수다.
    // 하지만 이대로 실행하면 오류가 뜬다. words[n]은 문자열 변수가 아니기 때문.
    // words[n]은 임의의 문자열 주소를 받는 값일 뿐, 문자열 자체인 게 아니다.

    // 해결법 2. words[n] = strdup(buffer)
    // 엄밀히 말하면 strdup은 C 표준은 아니다. 하지만 대부분의 컴파일러에서 지원
    // strdup은 매개변수로 하나의 문자열을 받고, 그 문자의 복제본을 만들어 주소값을 리턴하는 함수다.
    // 따라서 문자열 복제본의 주소를 반환하는 strdup을 words[n]에 연결하면 된다.

}

char * strdup(char *s){
    char *p;
    p=(char *)malloc(strlen(s)+1); // 문자열 + \0까지 해야 하기에 strlen(s)+1이다.
    if (p!=NULL){
        strcpy(p,s);
    }
    return p;
    // p는 문자열을 받기 위해 정의된 배열이므로, strcpy(p,s)가 가능한 것.
}

/// 파일로부터 데이터 읽기 / 쓰기

#include <stdio.h>

void main() {
    FILE *in_fp = fopen("input.txt","r");
    FILE * out_fp = fopen("output.txt","w");
    char buffer[100];
    while (fscanf(in_fp,"%s",buffer)!=EOF){
        fprintf(out_fp,"%s",buffer);
    }
    fclose(in_fp);
    fclose(out_fp;)
}

