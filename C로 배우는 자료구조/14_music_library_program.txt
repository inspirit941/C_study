//프로그램 실행 시, 어떤 데이터파일을 로드할건지 묻는다. 그냥 enter치면 load하지 않는다.
// Data file loaded.
// status : 노래에 대한 모든 정보를 화면에 출력
// 가수명, 제목, 경로명 저장.
// 입력 순서대로 프로그램이 앞에서부터 번호 할당. (알파벳순으로 정렬)
// add : 새 노래 추가 명령어
// 아티스트명, 제목명, 파일경로(경로는 없어도 된다)
// search : 검색기능 -> 가수이름과 노래제목으로
// 가수 이름만으로도 검색 가능 (노래제목을 공란으로 설정해도 ㄱㅊ)
// play : 실제로 노래 재생. 노래 번호만으로도 재생 가능하도록.
// delete : 노래 번호를 변수로 받아서 목록에서 삭제하는 기능.
// save : 목록을 파일에 저장한다
// exit : 탈출명령어

// 파일 형식:
// 한 줄에 노래 하나씩. 가수 / 제목 / 경로명 세 개의 값으로. 구분자는 #, 존재하지 않으면 공백문자로 표시.
// 자료구조 정의하기
// Artist객체: 한 명의 가수를 표현하는 개체.
// name, next, head, tail (가수들은 단방향 연결리스트로 연결할 것. 따라서 next)
// 가수가 부른 노래들-> song 객체로 표현.
// song 객체: artist, title, path, index.
// song 객체의 첫번째는 head, 마지막은 tail.

/// SNode라는 struct 따로 정의해서
// Snode는 node 역할을 전담한다 (next, prev, song)
// song 항목에 song 객체 주소를 저장한다.
// 즉, song이라는 struct들은 노드에 붙어 있는 데이터 객체일 뿐이다.
// 양방향 연결리스트는 Snode가 담당한다. 

// Snode를 따로 만드는 이유???
// 연결리스트를 만들 때 연결리스트의 노드와 데이터객체를 분리하는 이유
// -> 가수별, 플레이리스트별 등등 여러 가지의 기준으로 데이터를 보고자 할 때
// Snode로 연결 리스트 만드는 편이 song 객체의 지나친 중복을 막을 수 있다.

// 가수들의 이름 저장: 
// artist를 이니셜에 따라 분류해서, 각 그룹을 하나의 단방향 연결리스트로 저장할 것.
// search하기 쉬워짐

// index 번호만으로 노래를 재생하거나 삭제하려면?
// song을 index를 size로 나눈 나머지가 동일한 것들끼리 분류 -> 각 그룹을 하나의 단방향리스트로 연결

// 즉 song이라는 객체는 하나만 생성하고, 이 객체를 여러 루트를 통해 접근할 수 있도록 만든다는 취지

///// 프로그램을 여러 개의 소스파일로 구성하기
// C 프로그램은 여러 개의 소스 파일로 구성된다.
// 관습적으로 각각의 소스파일은 확장자 .c를 갖는다
// 하나의 소스파일은 main이라는 이름의 함수를 가져야 한다

// 여러 개의 소스파일로 분할할 경우 장점:
// 연관된 함수들과 변수들이 하나의 파일에 있으므로 구조를 보기 편해진다 (모듈화)
// 각각의 소스파일을 개별적으로 컴파일할 수 있어 시간이 절약된다
// 소프트웨어 재사용이 용이하다

// 소스파일을 세 개로 만들 생각 - string_tools.c library.c main.c
// main.c -> 사용자와 상호작용하는 부분을 구성
// library.c -> 실제로 프로그램이 일하는 대부분의 방식-음원데이터 추가, 검색, 삭제, 관리
// 입력을 라인 단위로 읽고 문자열이나 토큰처리와 관련한 함수들

// 다른 소스파일에 속해있는 함수를 호출해야 하는 경우
// -> 다른 파일에 정의된 함수를 어떻게 호출할 건가
// -> 다른 파일에 정의된 변수를 어떻게 쓸 건가
// -> 서로 다른 파일들이 매크로나 타입정의를 어떻게 공유할 건가
// 매크로: #define
// 타입: struct 등
// 변수와 함수

// 다른 파일에서도 써야 하는 매크로, 타입, 변수, 함수는 header파일에 정의를 선언한다.
// 그리고 include를 선언하면 됨. library.h 라는 헤더파일을 정의하고
// #include "library.h"를 library.c 맨 윗자리에 넣는다.
// library.c로 정의한 다음, 다른 곳에서도 쓰일 함수나 변수를 library.h 파일을 새로 만들어 정의한다
// main.c에서는 #include "library.h"를 통해 불러온다

// 함수의 경우 library.c에 구현하고, 헤더파일엔 prototype만 넣는다

// 서로 다인 파일 간의 '변수'공유... 좀 복잡

// c언어는 변수의 선언 declaration과 정의 definition을 구분한다.
/* 
선언: 컴파일러에게 변수의 존재를 알려주는 것.
정의: 실제로 메모리를 할당하는 것
int i; 
-> 선언과 정의를 동시에 시행한 것.
extern int i; -> 변수 i를 선언하는 것. 어딘가에 있다는 것만 컴파일러에게 가르쳐주는 것.
(지금 이 파일 안에는 i가 정의되어 있지 않지만, 다른 파일에 i가 정의되어 있다. 참고해라 정도?)
extern int a[]; (배열 크기도 정해줄 필요 없다)

서로 다른 파일간 변수 공유
공유 변수의 선언은 헤더파일에 둔다
공유변수를 사용하는 모든 소스파일은 헤더 파일을 include해야 한다
소스파일 중 오직 한 곳에서만 공유변수를 정의한다.
 (하지만 C언어에서 공유변수가 있는 건 그닥 좋은 현상이 아니라고 함)
ex) file.h
extern int global_variable;

file.c
#include file.h
int global variable;

file2.c
#include "file.h"
printf("%d\n",global_variable++);
*/

// 중첩된 include문제
// 항상 오류인 건 아니다. 매크로정의, 함수 프로토타입, extern 변수 선언은 여러 번 중복되어도 상관없다
// 다만 타입 정의가 중복되면 컴파일 오류가 난다.
// 두 개의 헤더파일을 가져왔는데, 둘 다 struct a를 정의하고 있다면 충돌 생기겠지

// 해결법:
/*
#ifndef BOOLEAN_H
#define BOOLEAN_H
 (boolean h 매크로가 정의되어 있지 않다면 #define BOOLEAN_H 부터 endif까지를 정의한다)
#define TRUE 1
#define FALSE 0
typedef int Bool;
#endif

*/